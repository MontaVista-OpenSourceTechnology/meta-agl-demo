From a22d972bc497ab46d99c1d118bd40b9471fef3a7 Mon Sep 17 00:00:00 2001
From: Scott Murray <scott.murray@konsulko.com>
Date: Mon, 13 Jun 2022 12:54:54 -0400
Subject: [PATCH] dbc2val: add duplicate filtering option

To avoid generating a lot of duplicated signal events from the
CAN messages generated by LIN polling, add a per-target
"filter-duplicates" option that can be used for signals where
only changes should be pushed toi the VIS server.  This is
required with the current performance of the DBC feeder to avoid
ending up with an increasing backlog of signal commands to the
server.  This will be investigated with upstream.

Upstream-Status: pending
Signed-off-by: Scott Murray <scott.murray@konsulko.com>
---
 kuksa_feeders/dbc2val/dbc2vssmapper.py | 27 +++++++++++++++++++-------
 1 file changed, 20 insertions(+), 7 deletions(-)

diff --git a/kuksa_feeders/dbc2val/dbc2vssmapper.py b/kuksa_feeders/dbc2val/dbc2vssmapper.py
index 1718154..2feb572 100644
--- a/kuksa_feeders/dbc2val/dbc2vssmapper.py
+++ b/kuksa_feeders/dbc2val/dbc2vssmapper.py
@@ -48,14 +48,27 @@ class mapper:
     # Check whether there are transforms defined to map DBC signal "signal" to 
     # VSS path "target". Returns the (potentially) transformed values
     def transform(self,signal, target, value):
-        if "transform" not in self.mapping[signal]["targets"][target].keys(): #no transform defined, return as is
-            return value
-        for transform in self.mapping[signal]["targets"][target]["transform"]:
-            if transform in self.transforms.keys():  #found a known transform and apply
-                value=self.transforms[transform].transform(self.mapping[signal]["targets"][target]["transform"][transform],value)
+        result = value
+        if "transform" in self.mapping[signal]["targets"][target].keys():
+            for transform in self.mapping[signal]["targets"][target]["transform"]:
+                if transform in self.transforms.keys():  #found a known transform and apply
+                    result = self.transforms[transform].transform(self.mapping[signal]["targets"][target]["transform"][transform],value)
+                else:
+                    print(f"Warning: Unknown transform {transform} for {signal}->{target}")
+        # else no transform defined, return as is
+
+        if (("filter-duplicates" in self.mapping[signal]["targets"][target]) and
+            self.mapping[signal]["targets"][target]["filter-duplicates"] == "true"):
+            if "last" in self.mapping[signal]["targets"][target]:
+                if self.mapping[signal]["targets"][target]["last"] == result:
+                    # ignore duplicate value
+                    result = None
+                else:
+                    self.mapping[signal]["targets"][target]["last"] = result
             else:
-                print(f"Warning: Unknown transform {transform} for {signal}->{target}")
-        return value
+                self.mapping[signal]["targets"][target]["last"] = result
+
+        return result
 
     def __contains__(self,key):
         return key in self.mapping.keys()
-- 
2.35.1

