From d50bcc010ca2856979f58b2ffbd0015514c4231f Mon Sep 17 00:00:00 2001
From: Roger Zanoni <rzanoni@igalia.com>
Date: Wed, 17 May 2023 21:25:53 +0200
Subject: [PATCH 02/33] [agl] Add waylandwindow/window tree host essential
 parts

This is a backport of the work we did on top of chromium webosose to be
able to communicate with the agl compositor.

Signed-off-by: Roger Zanoni <rzanoni@igalia.com>
---
 ui/aura/BUILD.gn                              |  7 ++
 ui/aura/agl/window_tree_host_agl.h            | 42 +++++++++
 ui/aura/agl/window_tree_host_platform_agl.cc  | 50 +++++++++++
 ui/aura/agl/window_tree_host_platform_agl.h   | 51 +++++++++++
 ui/aura/window_tree_host.h                    |  5 +-
 ui/aura/window_tree_host_platform.cc          |  4 +-
 ui/aura/window_tree_host_platform.h           |  4 +-
 ui/ozone/platform/wayland/BUILD.gn            |  1 -
 .../platform/wayland/extensions/agl/BUILD.gn  |  2 +
 .../agl/host/wayland_extensions_agl.h         | 10 ++-
 .../agl/host/wayland_extensions_agl_impl.cc   | 11 ++-
 .../agl/host/wayland_extensions_agl_impl.h    |  9 ++
 .../extensions/agl/host/wayland_window_agl.cc | 86 +++++++++++++++++++
 .../extensions/agl/host/wayland_window_agl.h  | 49 +++++++++++
 .../wayland/gpu/gl_surface_wayland.cc         |  9 +-
 .../host/gtk_primary_selection_device.cc      |  2 +-
 .../gtk_primary_selection_device_manager.cc   |  4 +-
 .../wayland/host/proxy/wayland_proxy_impl.cc  |  2 +-
 .../wayland/host/wayland_connection.cc        | 19 +++-
 .../wayland/host/wayland_connection.h         |  9 +-
 .../platform/wayland/host/wayland_cursor.cc   |  4 +-
 .../wayland/host/wayland_data_device.cc       | 10 +--
 .../wayland/host/wayland_data_device_base.cc  |  2 +-
 .../host/wayland_data_drag_controller.cc      |  2 +-
 .../wayland/host/wayland_data_source.cc       |  6 +-
 ui/ozone/platform/wayland/host/wayland_drm.cc |  6 +-
 .../wayland/host/wayland_extensions.h         |  6 ++
 .../platform/wayland/host/wayland_keyboard.cc |  4 +-
 .../platform/wayland/host/wayland_popup.cc    |  8 +-
 .../platform/wayland/host/wayland_seat.cc     |  2 +-
 ui/ozone/platform/wayland/host/wayland_shm.cc |  2 +-
 .../platform/wayland/host/wayland_surface.cc  |  2 +-
 .../wayland/host/wayland_toplevel_window.cc   | 18 ++--
 .../platform/wayland/host/wayland_window.cc   |  6 +-
 .../platform/wayland/host/wayland_window.h    |  2 +
 .../host/wayland_window_drag_controller.cc    |  2 +-
 .../wayland/host/wayland_window_factory.cc    | 14 +++
 .../wayland/host/wayland_zwp_linux_dmabuf.cc  |  4 +-
 .../wayland/host/xdg_foreign_wrapper.cc       |  4 +-
 .../wayland/host/xdg_popup_wrapper_impl.cc    |  2 +-
 .../wayland/host/xdg_surface_wrapper_impl.cc  |  2 +-
 .../wayland/host/xdg_toplevel_wrapper_impl.cc |  2 +-
 .../host/zwp_primary_selection_device.cc      |  2 +-
 .../zwp_primary_selection_device_manager.cc   |  4 +-
 ui/platform_window/agl/platform_window_agl.h  | 36 ++++++++
 ui/platform_window/platform_window.h          |  4 +-
 46 files changed, 469 insertions(+), 63 deletions(-)
 create mode 100644 ui/aura/agl/window_tree_host_agl.h
 create mode 100644 ui/aura/agl/window_tree_host_platform_agl.cc
 create mode 100644 ui/aura/agl/window_tree_host_platform_agl.h
 create mode 100644 ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.cc
 create mode 100644 ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h
 create mode 100644 ui/platform_window/agl/platform_window_agl.h

diff --git a/ui/aura/BUILD.gn b/ui/aura/BUILD.gn
index 50ca856b9da18..8fa04492f69f7 100644
--- a/ui/aura/BUILD.gn
+++ b/ui/aura/BUILD.gn
@@ -99,6 +99,13 @@ component("aura") {
     "window_tree_host_platform.cc",
   ]
 
+  public += [
+    "agl/window_tree_host_agl.h",
+    "agl/window_tree_host_platform_agl.h"
+  ]
+
+  sources += [ "agl/window_tree_host_platform_agl.cc" ]
+
   friend = [ ":*" ]
 
   defines = [ "AURA_IMPLEMENTATION" ]
diff --git a/ui/aura/agl/window_tree_host_agl.h b/ui/aura/agl/window_tree_host_agl.h
new file mode 100644
index 0000000000000..858a078d939d0
--- /dev/null
+++ b/ui/aura/agl/window_tree_host_agl.h
@@ -0,0 +1,42 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef UI_AURA_AGL_WINDOW_TREE_HOST_AGL_H_
+#define UI_AURA_AGL_WINDOW_TREE_HOST_AGL_H_
+
+#include <string>
+
+#include "ui/aura/aura_export.h"
+
+namespace aura {
+
+class AURA_EXPORT WindowTreeHostAgl {
+ public:
+  WindowTreeHostAgl() = default;
+  WindowTreeHostAgl(const WindowTreeHostAgl&) = delete;
+  WindowTreeHostAgl& operator=(const WindowTreeHostAgl&) = delete;
+  ~WindowTreeHostAgl() = default;
+
+  virtual void SetAglActivateApp(const std::string& app) {}
+  virtual void SetAglAppId(const std::string& title) {}
+  virtual void SetAglReady() {}
+  virtual void SetAglBackground() {}
+  virtual void SetAglPanel(uint32_t edge) {}
+};
+
+}  // namespace aura
+
+#endif  // UI_AURA_AGL_WINDOW_TREE_HOST_AGL_H_
diff --git a/ui/aura/agl/window_tree_host_platform_agl.cc b/ui/aura/agl/window_tree_host_platform_agl.cc
new file mode 100644
index 0000000000000..e34595fe0ed9c
--- /dev/null
+++ b/ui/aura/agl/window_tree_host_platform_agl.cc
@@ -0,0 +1,50 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#include "ui/aura/agl/window_tree_host_platform_agl.h"
+
+#include "ui/aura/window_tree_host_platform.h"
+#include "ui/platform_window/platform_window.h"
+
+namespace aura {
+
+WindowTreeHostPlatformAgl::WindowTreeHostPlatformAgl(
+    std::unique_ptr<Window> window,
+    aura::WindowTreeHostPlatform* window_tree_host_platform)
+    : aura::WindowTreeHost(std::move(window)),
+      window_tree_host_platform_(window_tree_host_platform) {}
+
+void WindowTreeHostPlatformAgl::SetAglActivateApp(const std::string& app) {
+  window_tree_host_platform_->platform_window()->SetAglActivateApp(app);
+}
+
+void WindowTreeHostPlatformAgl::SetAglAppId(const std::string& title) {
+  window_tree_host_platform_->platform_window()->SetAglAppId(title);
+}
+
+void WindowTreeHostPlatformAgl::SetAglReady() {
+  window_tree_host_platform_->platform_window()->SetAglReady();
+}
+
+void WindowTreeHostPlatformAgl::SetAglBackground() {
+  window_tree_host_platform_->platform_window()->SetAglBackground();
+}
+
+void WindowTreeHostPlatformAgl::SetAglPanel(uint32_t edge) {
+  window_tree_host_platform_->platform_window()->SetAglPanel(edge);
+}
+
+}  // namespace aura
diff --git a/ui/aura/agl/window_tree_host_platform_agl.h b/ui/aura/agl/window_tree_host_platform_agl.h
new file mode 100644
index 0000000000000..181eefae346f7
--- /dev/null
+++ b/ui/aura/agl/window_tree_host_platform_agl.h
@@ -0,0 +1,51 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef UI_AURA_AGL_WINDOW_TREE_HOST_PLATFORM_AGL_H_
+#define UI_AURA_AGL_WINDOW_TREE_HOST_PLATFORM_AGL_H_
+
+#include <memory>
+
+#include "ui/aura/aura_export.h"
+#include "ui/aura/window_tree_host.h"
+
+namespace aura {
+
+class Window;
+class WindowTreeHostPlatform;
+
+class AURA_EXPORT WindowTreeHostPlatformAgl : public aura::WindowTreeHost {
+ public:
+  explicit WindowTreeHostPlatformAgl(
+      std::unique_ptr<Window> window,
+      aura::WindowTreeHostPlatform* window_tree_host_platform);
+  WindowTreeHostPlatformAgl(const WindowTreeHostPlatformAgl&) = delete;
+  WindowTreeHostPlatformAgl& operator=(const WindowTreeHostPlatformAgl&) = delete;
+  ~WindowTreeHostPlatformAgl() override = default;
+
+  void SetAglActivateApp(const std::string& app) override;
+  void SetAglAppId(const std::string& title) override;
+  void SetAglReady() override;
+  void SetAglBackground() override;
+  void SetAglPanel(uint32_t edge) override;
+
+ private:
+  aura::WindowTreeHostPlatform* window_tree_host_platform_;
+};
+
+}  // namespace aura
+
+#endif  // UI_AURA_AGL_WINDOW_TREE_HOST_PLATFORM_AGL_H_
diff --git a/ui/aura/window_tree_host.h b/ui/aura/window_tree_host.h
index b4b6e7022ea34..afb37a3a3ed13 100644
--- a/ui/aura/window_tree_host.h
+++ b/ui/aura/window_tree_host.h
@@ -30,6 +30,8 @@
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gfx/overlay_transform.h"
 
+#include "ui/aura/agl/window_tree_host_agl.h"
+
 namespace gfx {
 class Point;
 class Rect;
@@ -66,7 +68,8 @@ class WindowTreeHostObserver;
 class AURA_EXPORT WindowTreeHost : public ui::ImeKeyEventDispatcher,
                                    public ui::EventSource,
                                    public display::DisplayObserver,
-                                   public ui::CompositorObserver {
+                                   public ui::CompositorObserver,
+                                   public WindowTreeHostAgl {
  public:
   // VideoCaptureLock ensures state necessary for capturing video remains in
   // effect. For example, this may force keeping the compositor visible when
diff --git a/ui/aura/window_tree_host_platform.cc b/ui/aura/window_tree_host_platform.cc
index fd4a560f6cdd1..33b9e892c0212 100644
--- a/ui/aura/window_tree_host_platform.cc
+++ b/ui/aura/window_tree_host_platform.cc
@@ -52,7 +52,7 @@ std::unique_ptr<WindowTreeHost> WindowTreeHost::Create(
 WindowTreeHostPlatform::WindowTreeHostPlatform(
     ui::PlatformWindowInitProperties properties,
     std::unique_ptr<Window> window)
-    : WindowTreeHost(std::move(window)) {
+    : WindowTreeHostPlatformAgl(std::move(window), this) {
   size_in_pixels_ = properties.bounds.size();
   CreateCompositor(false, false, properties.enable_compositing_based_throttling,
                    properties.compositor_memory_limit_mb);
@@ -60,7 +60,7 @@ WindowTreeHostPlatform::WindowTreeHostPlatform(
 }
 
 WindowTreeHostPlatform::WindowTreeHostPlatform(std::unique_ptr<Window> window)
-    : WindowTreeHost(std::move(window)),
+    : WindowTreeHostPlatformAgl(std::move(window), this),
       widget_(gfx::kNullAcceleratedWidget),
       current_cursor_(ui::mojom::CursorType::kNull) {}
 
diff --git a/ui/aura/window_tree_host_platform.h b/ui/aura/window_tree_host_platform.h
index 92ae0f0229e70..9c3f742c30ad3 100644
--- a/ui/aura/window_tree_host_platform.h
+++ b/ui/aura/window_tree_host_platform.h
@@ -15,6 +15,8 @@
 #include "ui/gfx/native_widget_types.h"
 #include "ui/platform_window/platform_window_delegate.h"
 
+#include "ui/aura/agl/window_tree_host_platform_agl.h"
+
 namespace ui {
 enum class DomCode;
 class PlatformWindow;
@@ -26,7 +28,7 @@ namespace aura {
 
 // The unified WindowTreeHost implementation for platforms
 // that implement PlatformWindow.
-class AURA_EXPORT WindowTreeHostPlatform : public WindowTreeHost,
+class AURA_EXPORT WindowTreeHostPlatform : public WindowTreeHostPlatformAgl,
                                            public ui::PlatformWindowDelegate {
  public:
   explicit WindowTreeHostPlatform(ui::PlatformWindowInitProperties properties,
diff --git a/ui/ozone/platform/wayland/BUILD.gn b/ui/ozone/platform/wayland/BUILD.gn
index 8a436de0fafe3..754cb123043a9 100644
--- a/ui/ozone/platform/wayland/BUILD.gn
+++ b/ui/ozone/platform/wayland/BUILD.gn
@@ -400,7 +400,6 @@ source_set("wayland") {
 
   sources += [
    "host/wayland_extensions.h",
-   "host/wayland_extensions_stub.cc",
   ]
 
   deps += [ "extensions/agl" ]
diff --git a/ui/ozone/platform/wayland/extensions/agl/BUILD.gn b/ui/ozone/platform/wayland/extensions/agl/BUILD.gn
index ce289bc5dbbca..01c590e53df58 100644
--- a/ui/ozone/platform/wayland/extensions/agl/BUILD.gn
+++ b/ui/ozone/platform/wayland/extensions/agl/BUILD.gn
@@ -31,6 +31,8 @@ source_set("agl") {
     "host/wayland_extensions_agl.h",
     "host/wayland_extensions_agl_impl.cc",
     "host/wayland_extensions_agl_impl.h",
+    "host/wayland_window_agl.cc",
+    "host/wayland_window_agl.h",
   ]
 
   deps = [
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h
index df42fc00c84da..295154dfb437d 100644
--- a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h
@@ -20,6 +20,9 @@
 namespace ui {
 
 class AglShellWrapper;
+class PlatformWindowDelegate;
+class WaylandConnection;
+class WaylandWindow;
 
 // AGL extensions implementation for webOS/Lite
 class WaylandExtensionsAgl {
@@ -29,9 +32,14 @@ class WaylandExtensionsAgl {
   WaylandExtensionsAgl& operator=(const WaylandExtensionsAgl&) = delete;
   virtual ~WaylandExtensionsAgl() = default;
 
+  virtual std::unique_ptr<WaylandWindow> CreateWaylandWindow(
+      PlatformWindowDelegate* delegate,
+      WaylandConnection* connection) = 0;
+
+
   virtual AglShellWrapper* GetAglShell() = 0;
 };
 
 }  // namespace ui
 
-#endif  // UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_EXTENSIONS_AGL_H_
\ No newline at end of file
+#endif  // UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_EXTENSIONS_AGL_H_
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.cc b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.cc
index 26a5f0550c302..87376cbb8a9d3 100644
--- a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.cc
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.cc
@@ -22,6 +22,7 @@
 #include "base/logging.h"
 #include "ui/base/ui_base_switches.h"
 #include "ui/ozone/platform/wayland/extensions/agl/host/agl_shell_wrapper.h"
+#include "ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h"
 #include "ui/ozone/platform/wayland/extensions/agl/common/wayland_object_agl.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 
@@ -68,8 +69,8 @@ bool WaylandExtensionsAglImpl::Bind(wl_registry* registry,
     agl_shell_ =
         std::make_unique<AglShellWrapper>(aglshell.release(), connection_);
 
-    LOG(INFO) << "Waiting until bound...";
-    return agl_shell_->WaitUntilBoundOk();
+    //LOG(INFO) << "Waiting until bound...";
+    //return agl_shell_->WaitUntilBoundOk();
   } else {
     LOG(INFO) << "Cant bind.";
   }
@@ -85,6 +86,12 @@ AglShellWrapper* WaylandExtensionsAglImpl::GetAglShell() {
   return agl_shell_.get();
 }
 
+std::unique_ptr<WaylandWindow> WaylandExtensionsAglImpl::CreateWaylandWindow(
+    PlatformWindowDelegate* delegate,
+    WaylandConnection* connection) {
+  return std::make_unique<WaylandWindowAgl>(delegate, connection, this);
+}
+
 std::unique_ptr<WaylandExtensions> CreateWaylandExtensions(
     WaylandConnection* connection) {
   return std::make_unique<WaylandExtensionsAglImpl>(connection);
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.h b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.h
index f6cbabe99ed0b..3218589f1a09a 100644
--- a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.h
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.h
@@ -17,12 +17,17 @@
 #ifndef UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_EXTENSIONS_AGL_IMPL_H_
 #define UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_EXTENSIONS_AGL_IMPL_H_
 
+#include <memory>
+
 #include "ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h"
 #include "ui/ozone/platform/wayland/host/wayland_extensions.h"
 
 namespace ui {
 
 class AglShellWrapper;
+class PlatformWindowDelegate;
+class WaylandConnection;
+class WaylandWindow;
 
 // AGL extension implementation for webOS/Lite
 class WaylandExtensionsAglImpl : public WaylandExtensions,
@@ -44,6 +49,10 @@ class WaylandExtensionsAglImpl : public WaylandExtensions,
   // WaylandExtensionsAgl overrides
   AglShellWrapper* GetAglShell() override;
 
+  std::unique_ptr<WaylandWindow> CreateWaylandWindow(
+      PlatformWindowDelegate* delegate,
+      WaylandConnection* connection) override;
+
  private:
   std::unique_ptr<AglShellWrapper> agl_shell_;
   WaylandConnection* connection_;
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.cc b/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.cc
new file mode 100644
index 0000000000000..97b21ae537658
--- /dev/null
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.cc
@@ -0,0 +1,86 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#include "ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h"
+
+#include "base/logging.h"
+#include "ui/ozone/platform/wayland/extensions/agl/host/agl_shell_wrapper.h"
+#include "ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h"
+#include "ui/ozone/platform/wayland/host/shell_surface_wrapper.h"
+#include "ui/ozone/platform/wayland/host/shell_toplevel_wrapper.h"
+#include "ui/ozone/platform/wayland/host/wayland_connection.h"
+
+namespace ui {
+
+WaylandWindowAgl::WaylandWindowAgl(PlatformWindowDelegate* delegate,
+                                   WaylandConnection* connection,
+                                   WaylandExtensionsAgl* agl_extensions)
+    : WaylandToplevelWindow(delegate, connection),
+      agl_extensions_(agl_extensions) {}
+
+WaylandWindowAgl::~WaylandWindowAgl() = default;
+
+void WaylandWindowAgl::SetAglActivateApp(const std::string& app) {
+  if (!agl_extensions_->GetAglShell()) {
+    LOG(ERROR) << "Agl shell wrapper is not created";
+    return;
+  }
+
+  agl_extensions_->GetAglShell()->SetAglActivateApp(app);
+  connection()->ScheduleFlush();
+}
+
+void WaylandWindowAgl::SetAglAppId(const std::string& title) {
+  if (!shell_toplevel()) {
+    LOG(ERROR) << "Shell toplevel is not created";
+    return;
+  }
+
+  shell_toplevel()->SetAppId(title);
+  connection()->ScheduleFlush();
+}
+
+void WaylandWindowAgl::SetAglReady() {
+  if (!agl_extensions_->GetAglShell()) {
+    LOG(ERROR) << "Agl shell wrapper is not created";
+    return;
+  }
+
+  agl_extensions_->GetAglShell()->SetAglReady();
+  connection()->ScheduleFlush();
+}
+
+void WaylandWindowAgl::SetAglBackground() {
+  if (!agl_extensions_->GetAglShell()) {
+    LOG(ERROR) << "Agl shell wrapper is not created";
+    return;
+  }
+
+  agl_extensions_->GetAglShell()->SetAglBackground(this);
+  connection()->ScheduleFlush();
+}
+
+void WaylandWindowAgl::SetAglPanel(uint32_t edge) {
+  if (!agl_extensions_->GetAglShell()) {
+    LOG(ERROR) << "Agl shell wrapper is not created";
+    return;
+  }
+
+  agl_extensions_->GetAglShell()->SetAglPanel(this, edge);
+  connection()->ScheduleFlush();
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h b/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h
new file mode 100644
index 0000000000000..b2a922604c001
--- /dev/null
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h
@@ -0,0 +1,49 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+//
+
+#ifndef UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_WINDOW_AGL_H_
+#define UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_WINDOW_AGL_H_
+
+#include "ui/ozone/platform/wayland/host/wayland_toplevel_window.h"
+
+namespace ui {
+
+class WaylandExtensionsAgl;
+
+class WaylandWindowAgl : public WaylandToplevelWindow {
+ public:
+  explicit WaylandWindowAgl(PlatformWindowDelegate* delegate,
+                            WaylandConnection* connection,
+                            WaylandExtensionsAgl* agl_extensions);
+  WaylandWindowAgl(const WaylandWindowAgl&) = delete;
+  WaylandWindowAgl& operator=(const WaylandWindowAgl&) = delete;
+  ~WaylandWindowAgl() override;
+
+  // Overrides PlatformWindowAgl
+  void SetAglActivateApp(const std::string& app) override;
+  void SetAglAppId(const std::string& title) override;
+  void SetAglReady() override;
+  void SetAglBackground() override;
+  void SetAglPanel(uint32_t edge) override;
+
+ private:
+  WaylandExtensionsAgl* agl_extensions_;
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_WINDOW_AGL_H_
diff --git a/ui/ozone/platform/wayland/gpu/gl_surface_wayland.cc b/ui/ozone/platform/wayland/gpu/gl_surface_wayland.cc
index 1cda8aa671ddb..220f759ff30a1 100644
--- a/ui/ozone/platform/wayland/gpu/gl_surface_wayland.cc
+++ b/ui/ozone/platform/wayland/gpu/gl_surface_wayland.cc
@@ -90,7 +90,14 @@ gfx::SwapResult GLSurfaceWayland::SwapBuffers(PresentationCallback callback,
     return scoped_swap_buffers.result();
   }
   window_->root_surface()->set_surface_buffer_scale(scale_factor_);
-  return gl::NativeViewGLSurfaceEGL::SwapBuffers(std::move(callback), data);
+
+  gfx::SwapResult result = gl::NativeViewGLSurfaceEGL::SwapBuffers(std::move(callback), data);
+
+  if (window_) {
+    window_->OnSurfaceContentChanged();
+  }
+
+  return result;
 }
 
 gfx::SwapResult GLSurfaceWayland::PostSubBuffer(int x,
diff --git a/ui/ozone/platform/wayland/host/gtk_primary_selection_device.cc b/ui/ozone/platform/wayland/host/gtk_primary_selection_device.cc
index c62dd62be4fbf..2959593cfeb5b 100644
--- a/ui/ozone/platform/wayland/host/gtk_primary_selection_device.cc
+++ b/ui/ozone/platform/wayland/host/gtk_primary_selection_device.cc
@@ -32,7 +32,7 @@ void GtkPrimarySelectionDevice::SetSelectionSource(
   auto* data_source = source ? source->data_source() : nullptr;
   gtk_primary_selection_device_set_selection(data_device_.get(), data_source,
                                              serial);
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 // static
diff --git a/ui/ozone/platform/wayland/host/gtk_primary_selection_device_manager.cc b/ui/ozone/platform/wayland/host/gtk_primary_selection_device_manager.cc
index 2c39409808128..1e07ae6009776 100644
--- a/ui/ozone/platform/wayland/host/gtk_primary_selection_device_manager.cc
+++ b/ui/ozone/platform/wayland/host/gtk_primary_selection_device_manager.cc
@@ -66,7 +66,7 @@ GtkPrimarySelectionDevice* GtkPrimarySelectionDeviceManager::GetDevice() {
         connection_,
         gtk_primary_selection_device_manager_get_device(
             device_manager_.get(), connection_->seat()->wl_object()));
-    connection_->Flush();
+    connection_->ScheduleFlush();
   }
   DCHECK(device_);
   return device_.get();
@@ -77,7 +77,7 @@ GtkPrimarySelectionDeviceManager::CreateSource(
     GtkPrimarySelectionSource::Delegate* delegate) {
   auto* data_source =
       gtk_primary_selection_device_manager_create_source(device_manager_.get());
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return std::make_unique<GtkPrimarySelectionSource>(data_source, connection_,
                                                      delegate);
 }
diff --git a/ui/ozone/platform/wayland/host/proxy/wayland_proxy_impl.cc b/ui/ozone/platform/wayland/host/proxy/wayland_proxy_impl.cc
index f2407d1c306ec..7a7868ded8a52 100644
--- a/ui/ozone/platform/wayland/host/proxy/wayland_proxy_impl.cc
+++ b/ui/ozone/platform/wayland/host/proxy/wayland_proxy_impl.cc
@@ -69,7 +69,7 @@ void WaylandProxyImpl::DestroyShmForWlBuffer(wl_buffer* buffer) {
 }
 
 void WaylandProxyImpl::FlushForTesting() {
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 ui::PlatformWindowType WaylandProxyImpl::GetWindowType(
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.cc b/ui/ozone/platform/wayland/host/wayland_connection.cc
index 7a47d4a636998..8d9e8eea6fd79 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/host/wayland_connection.cc
@@ -264,6 +264,20 @@ bool WaylandConnection::Initialize(bool use_threaded_polling) {
   return true;
 }
 
+void WaylandConnection::ScheduleFlush() {
+  // When we are in tests, the message loop is set later when the
+  // initialization of the OzonePlatform complete. Thus, just
+  // flush directly. This doesn't happen in normal run.
+  if (!base::CurrentUIThread::IsSet()) {
+    Flush();
+  } else if (!scheduled_flush_) {
+    base::SingleThreadTaskRunner::GetCurrentDefault()->PostTask(
+        FROM_HERE,
+        base::BindOnce(&WaylandConnection::Flush, base::Unretained(this)));
+    scheduled_flush_ = true;
+  }
+}
+
 void WaylandConnection::RoundTripQueue() {
   if (roundtrip_closure_for_testing_) {
     roundtrip_closure_for_testing_.Run();
@@ -333,6 +347,7 @@ void WaylandConnection::RegisterGlobalObjectFactory(
 
 void WaylandConnection::Flush() {
   wl_display_flush(display_.get());
+  scheduled_flush_ = false;
 }
 
 void WaylandConnection::UpdateInputDevices() {
@@ -526,7 +541,7 @@ void WaylandConnection::OnPing(void* data,
                                uint32_t serial) {
   auto* connection = static_cast<WaylandConnection*>(data);
   xdg_wm_base_pong(shell, serial);
-  connection->Flush();
+  connection->ScheduleFlush();
 }
 
 // static
@@ -707,7 +722,7 @@ void WaylandConnection::HandleGlobal(wl_registry* registry,
   }
 
   available_globals_.emplace_back(interface, version);
-  Flush();
+  ScheduleFlush();
 }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.h b/ui/ozone/platform/wayland/host/wayland_connection.h
index ba293e5bcd088..641f36f13db35 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.h
+++ b/ui/ozone/platform/wayland/host/wayland_connection.h
@@ -100,8 +100,8 @@ class WaylandConnection {
 
   bool Initialize(bool use_threaded_polling = false);
 
-  // Immediately flushes the Wayland display.
-  void Flush();
+  // Schedules a flush of the Wayland connection.
+  void ScheduleFlush();
 
   // Calls wl_display_roundtrip_queue. Might be required during initialization
   // of some objects that should block until they are initialized.
@@ -388,6 +388,9 @@ class WaylandConnection {
   friend class ZwpIdleInhibitManager;
   friend class ZwpPrimarySelectionDeviceManager;
 
+  // Immediately flushes the Wayland display.
+  void Flush();
+
   void RegisterGlobalObjectFactory(const char* interface_name,
                                    wl::GlobalObjectFactory factory);
 
@@ -535,6 +538,8 @@ class WaylandConnection {
   // This is set if delegated composition should not be used.
   bool overlay_delegation_disabled_ = false;
 
+  bool scheduled_flush_ = false;
+
   wl::SerialTracker serial_tracker_;
 
   // Global Wayland interfaces available in the current session, with their
diff --git a/ui/ozone/platform/wayland/host/wayland_cursor.cc b/ui/ozone/platform/wayland/host/wayland_cursor.cc
index 1b7d303291cff..a384212c84134 100644
--- a/ui/ozone/platform/wayland/host/wayland_cursor.cc
+++ b/ui/ozone/platform/wayland/host/wayland_cursor.cc
@@ -107,7 +107,7 @@ void WaylandCursor::HideCursor() {
   wl_surface_attach(pointer_surface_.get(), nullptr, 0, 0);
   wl_surface_commit(pointer_surface_.get());
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   if (listener_)
     listener_->OnCursorBufferAttached(nullptr);
@@ -166,7 +166,7 @@ void WaylandCursor::AttachAndCommit(wl_buffer* buffer,
   wl_pointer_set_cursor(pointer_->wl_object(), pointer_enter_serial->value,
                         pointer_surface_.get(), hotspot_x_dip, hotspot_y_dip);
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_data_device.cc b/ui/ozone/platform/wayland/host/wayland_data_device.cc
index a7adfd313188b..fe16d8577fd35 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_device.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_device.cc
@@ -51,7 +51,7 @@ void WaylandDataDevice::StartDrag(const WaylandDataSource& data_source,
                             origin_window.root_surface()->surface(),
                             icon_surface, serial);
   drag_delegate_->DrawIcon();
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandDataDevice::ResetDragDelegate() {
@@ -92,7 +92,7 @@ void WaylandDataDevice::SetSelectionSource(WaylandDataSource* source,
                                            uint32_t serial) {
   auto* data_source = source ? source->data_source() : nullptr;
   wl_data_device_set_selection(data_device_.get(), data_source, serial);
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandDataDevice::ReadDragDataFromFD(base::ScopedFD fd,
@@ -146,7 +146,7 @@ void WaylandDataDevice::OnEnter(void* data,
       gfx::PointF(wl_fixed_to_double(x), wl_fixed_to_double(y)), window);
   self->drag_delegate_->OnDragEnter(window, point, serial);
 
-  self->connection()->Flush();
+  self->connection()->ScheduleFlush();
 }
 
 void WaylandDataDevice::OnMotion(void* data,
@@ -167,7 +167,7 @@ void WaylandDataDevice::OnDrop(void* data, wl_data_device* data_device) {
   auto* self = static_cast<WaylandDataDevice*>(data);
   if (self->drag_delegate_) {
     self->drag_delegate_->OnDragDrop();
-    self->connection()->Flush();
+    self->connection()->ScheduleFlush();
   }
 
   // There are buggy Exo versions, which send 'drop' event (even for
@@ -184,7 +184,7 @@ void WaylandDataDevice::OnLeave(void* data, wl_data_device* data_device) {
   auto* self = static_cast<WaylandDataDevice*>(data);
   if (self->drag_delegate_) {
     self->drag_delegate_->OnDragLeave();
-    self->connection()->Flush();
+    self->connection()->ScheduleFlush();
   }
   self->ResetDragDelegateIfNotDragSource();
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_data_device_base.cc b/ui/ozone/platform/wayland/host/wayland_data_device_base.cc
index 203e907f92bfa..a0c72971ac567 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_device_base.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_device_base.cc
@@ -64,7 +64,7 @@ void WaylandDataDeviceBase::RegisterDeferredReadCallback() {
   static constexpr wl_callback_listener kSyncCallbackListener = {
       .done = &OnSyncDone};
   wl_callback_add_listener(sync_callback_.get(), &kSyncCallbackListener, this);
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 void WaylandDataDeviceBase::RegisterDeferredReadClosure(
diff --git a/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc b/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc
index 705bdec41a1b7..dfa5789e8d149 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc
@@ -256,7 +256,7 @@ void WaylandDataDragController::OnDragSurfaceFrame(void* data,
   DCHECK(self);
   self->DrawIconInternal();
   self->icon_frame_callback_.reset();
-  self->connection_->Flush();
+  self->connection_->ScheduleFlush();
 }
 
 SkBitmap WaylandDataDragController::GetIconBitmap() {
diff --git a/ui/ozone/platform/wayland/host/wayland_data_source.cc b/ui/ozone/platform/wayland/host/wayland_data_source.cc
index c0e95c8a22e48..c294ffb8836aa 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_source.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_source.cc
@@ -130,7 +130,7 @@ void DataSource<wl_data_source>::Offer(
     const std::vector<std::string>& mime_types) {
   for (auto& mime_type : mime_types)
     wl_data_source_offer(data_source_.get(), mime_type.c_str());
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 template <typename T>
@@ -165,7 +165,7 @@ void DataSource<gtk_primary_selection_source>::Offer(
     const std::vector<std::string>& mime_types) {
   for (const auto& mime_type : mime_types)
     gtk_primary_selection_source_offer(data_source_.get(), mime_type.c_str());
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 template <>
@@ -185,7 +185,7 @@ void DataSource<zwp_primary_selection_source_v1>::Offer(
   for (const auto& mime_type : mime_types)
     zwp_primary_selection_source_v1_offer(data_source_.get(),
                                           mime_type.c_str());
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 template class DataSource<gtk_primary_selection_source>;
diff --git a/ui/ozone/platform/wayland/host/wayland_drm.cc b/ui/ozone/platform/wayland/host/wayland_drm.cc
index 68570a9aacb2c..2b3b16e8859cb 100644
--- a/ui/ozone/platform/wayland/host/wayland_drm.cc
+++ b/ui/ozone/platform/wayland/host/wayland_drm.cc
@@ -58,7 +58,7 @@ WaylandDrm::WaylandDrm(wl_drm* drm, WaylandConnection* connection)
       .capabilities = &OnCapabilities,
   };
   wl_drm_add_listener(wl_drm_.get(), &kDrmListener, this);
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   // A roundtrip after binding guarantees that the client has received all
   // supported formats and capabilities of the device.
@@ -92,7 +92,7 @@ void WaylandDrm::CreateBuffer(const base::ScopedFD& fd,
   wl::Object<wl_buffer> buffer(wl_drm_create_prime_buffer(
       wl_drm_.get(), fd.get(), size.width(), size.height(), format, offset[0],
       stride[0], offset[1], stride[1], offset[2], stride[2]));
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   std::move(callback).Run(std::move(buffer));
 }
@@ -146,7 +146,7 @@ void WaylandDrm::Authenticate(const char* drm_device_path) {
   }
 
   wl_drm_authenticate(wl_drm_.get(), magic);
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   // Do the roundtrip to make sure the server processes this request and
   // authenticates us.
diff --git a/ui/ozone/platform/wayland/host/wayland_extensions.h b/ui/ozone/platform/wayland/host/wayland_extensions.h
index 3bd2fd7a211ae..f6ed47507d217 100644
--- a/ui/ozone/platform/wayland/host/wayland_extensions.h
+++ b/ui/ozone/platform/wayland/host/wayland_extensions.h
@@ -25,7 +25,9 @@ namespace ui {
 
 class ShellToplevelWrapper;
 class ShellPopupWrapper;
+class PlatformWindowDelegate;
 class WaylandConnection;
+class WaylandWindow;
 
 // Wayland extensions abstract interface to support extending of the Wayland
 // protocol. Inherit it to provide your own Wayland extensions implementation.
@@ -45,6 +47,10 @@ class WaylandExtensions {
 
   // Checks whether the extensions have bound shell object(s).
   virtual bool HasShellObject() const = 0;
+
+  virtual std::unique_ptr<WaylandWindow> CreateWaylandWindow(
+      PlatformWindowDelegate* delegate,
+      WaylandConnection* connection) = 0;
 };
 
 // Creates Wayland extensions.
diff --git a/ui/ozone/platform/wayland/host/wayland_keyboard.cc b/ui/ozone/platform/wayland/host/wayland_keyboard.cc
index 2b7fc05d426e1..f24d6993b26ac 100644
--- a/ui/ozone/platform/wayland/host/wayland_keyboard.cc
+++ b/ui/ozone/platform/wayland/host/wayland_keyboard.cc
@@ -114,7 +114,7 @@ class WaylandKeyboard::ZCRExtendedKeyboard {
 
   void AckKey(uint32_t serial, bool handled) {
     zcr_extended_keyboard_v1_ack_key(obj_.get(), serial, handled);
-    keyboard_->connection_->Flush();
+    keyboard_->connection_->ScheduleFlush();
   }
 
   // Returns true if connected object will send zcr_extended_keyboard::peek_key.
@@ -373,7 +373,7 @@ void WaylandKeyboard::FlushInput(base::OnceClosure closure) {
       .done = &OnSyncDone,
   };
   wl_callback_add_listener(sync_callback_.get(), &kSyncCallbackListener, this);
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 void WaylandKeyboard::DispatchKey(unsigned int key,
diff --git a/ui/ozone/platform/wayland/host/wayland_popup.cc b/ui/ozone/platform/wayland/host/wayland_popup.cc
index f1e886f8675fb..28903c031e6ce 100644
--- a/ui/ozone/platform/wayland/host/wayland_popup.cc
+++ b/ui/ozone/platform/wayland/host/wayland_popup.cc
@@ -132,7 +132,7 @@ void WaylandPopup::Show(bool inactive) {
     return;
   }
 
-  connection()->Flush();
+  connection()->ScheduleFlush();
   WaylandWindow::Show(inactive);
 }
 
@@ -158,7 +158,7 @@ void WaylandPopup::Hide() {
     decorated_via_aura_popup_ = false;
   }
 
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 bool WaylandPopup::IsVisible() const {
@@ -256,14 +256,14 @@ void WaylandPopup::ShowTooltip(const std::u16string& text,
   if (zaura_surface &&
       zaura_surface->ShowTooltip(text, position, zaura_shell_trigger,
                                  show_delay, hide_delay)) {
-    connection()->Flush();
+    connection()->ScheduleFlush();
   }
 }
 
 void WaylandPopup::HideTooltip() {
   auto* zaura_surface = GetZAuraSurface();
   if (zaura_surface && zaura_surface->HideTooltip()) {
-    connection()->Flush();
+    connection()->ScheduleFlush();
   }
 }
 
diff --git a/ui/ozone/platform/wayland/host/wayland_seat.cc b/ui/ozone/platform/wayland/host/wayland_seat.cc
index 3b05da49eb6b8..5f70725a9a9dd 100644
--- a/ui/ozone/platform/wayland/host/wayland_seat.cc
+++ b/ui/ozone/platform/wayland/host/wayland_seat.cc
@@ -128,7 +128,7 @@ void WaylandSeat::HandleCapabilities(void* data,
 
   connection_->UpdateInputDevices();
   connection_->UpdateCursor();
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_shm.cc b/ui/ozone/platform/wayland/host/wayland_shm.cc
index b264ad88962bb..95c19d9962085 100644
--- a/ui/ozone/platform/wayland/host/wayland_shm.cc
+++ b/ui/ozone/platform/wayland/host/wayland_shm.cc
@@ -62,7 +62,7 @@ wl::Object<wl_buffer> WaylandShm::CreateBuffer(const base::ScopedFD& fd,
       with_alpha_channel ? WL_SHM_FORMAT_ARGB8888 : WL_SHM_FORMAT_XRGB8888;
   wl::Object<wl_buffer> shm_buffer(wl_shm_pool_create_buffer(
       pool.get(), 0, size.width(), size.height(), size.width() * 4, format));
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return shm_buffer;
 }
 
diff --git a/ui/ozone/platform/wayland/host/wayland_surface.cc b/ui/ozone/platform/wayland/host/wayland_surface.cc
index 47dc846390898..2a04d28b05484 100644
--- a/ui/ozone/platform/wayland/host/wayland_surface.cc
+++ b/ui/ozone/platform/wayland/host/wayland_surface.cc
@@ -305,7 +305,7 @@ void WaylandSurface::UpdateBufferDamageRegion(const gfx::Rect& damage_px) {
 void WaylandSurface::Commit(bool flush) {
   wl_surface_commit(surface_.get());
   if (flush)
-    connection_->Flush();
+    connection_->ScheduleFlush();
 }
 
 void WaylandSurface::set_surface_buffer_scale(float scale) {
diff --git a/ui/ozone/platform/wayland/host/wayland_toplevel_window.cc b/ui/ozone/platform/wayland/host/wayland_toplevel_window.cc
index 898113178a783..1b489b327fa29 100644
--- a/ui/ozone/platform/wayland/host/wayland_toplevel_window.cc
+++ b/ui/ozone/platform/wayland/host/wayland_toplevel_window.cc
@@ -127,7 +127,7 @@ void WaylandToplevelWindow::DispatchHostWindowDragMovement(
   else
     shell_toplevel_->SurfaceResize(connection(), hittest);
 
-  connection()->Flush();
+  connection()->ScheduleFlush();
 #if !BUILDFLAG(IS_CHROMEOS_LACROS)
   // TODO(crbug.com/1454893): Revisit to resolve the correct impl.
   connection()->event_source()->ResetPointerFlags();
@@ -176,7 +176,7 @@ void WaylandToplevelWindow::Hide() {
     gtk_surface1_.reset();
 
   shell_toplevel_.reset();
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 bool WaylandToplevelWindow::IsVisible() const {
@@ -193,7 +193,7 @@ void WaylandToplevelWindow::SetTitle(const std::u16string& title) {
 
   if (shell_toplevel_) {
     shell_toplevel_->SetTitle(title);
-    connection()->Flush();
+    connection()->ScheduleFlush();
   }
 }
 
@@ -288,13 +288,13 @@ void WaylandToplevelWindow::Activate() {
   // but nothing more happens (until the user moves the mouse over a Lacros
   // window in which case events will start and the activation will come
   // through).
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandToplevelWindow::Deactivate() {
   if (shell_toplevel_ && shell_toplevel_->SupportsActivation()) {
     shell_toplevel_->Deactivate();
-    connection()->Flush();
+    connection()->ScheduleFlush();
   }
 }
 
@@ -722,14 +722,14 @@ void WaylandToplevelWindow::ShowTooltip(
   if (zaura_surface &&
       zaura_surface->ShowTooltip(text, position, zaura_shell_trigger,
                                  show_delay, hide_delay)) {
-    connection()->Flush();
+    connection()->ScheduleFlush();
   }
 }
 
 void WaylandToplevelWindow::HideTooltip() {
   auto* zaura_surface = GetZAuraSurface();
   if (zaura_surface && zaura_surface->HideTooltip()) {
-    connection()->Flush();
+    connection()->ScheduleFlush();
   }
 }
 
@@ -1001,7 +1001,7 @@ void WaylandToplevelWindow::TriggerStateChanges() {
   }
 
   delegate()->OnWindowStateChanged(previous_state_, state_);
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandToplevelWindow::SetWindowState(PlatformWindowState state) {
@@ -1035,7 +1035,7 @@ void WaylandToplevelWindow::SetSizeConstraints() {
   shell_toplevel_->SetCanMaximize(delegate()->CanMaximize());
   shell_toplevel_->SetCanFullscreen(delegate()->CanFullscreen());
 
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandToplevelWindow::SetOrResetRestoredBounds() {
diff --git a/ui/ozone/platform/wayland/host/wayland_window.cc b/ui/ozone/platform/wayland/host/wayland_window.cc
index ad4366edfe4db..9a18c567bcbcc 100644
--- a/ui/ozone/platform/wayland/host/wayland_window.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window.cc
@@ -686,6 +686,10 @@ std::string WaylandWindow::WindowStates::ToString() const {
   return states;
 }
 
+void WaylandWindow::OnSurfaceContentChanged() {
+  connection_->ScheduleFlush();
+}
+
 void WaylandWindow::HandleToplevelConfigure(int32_t widht,
                                             int32_t height,
                                             const WindowStates& window_states) {
@@ -832,7 +836,7 @@ bool WaylandWindow::Initialize(PlatformWindowInitProperties properties) {
   root_surface_->EnableTrustedDamageIfPossible();
   root_surface_->ApplyPendingState();
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   return true;
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_window.h b/ui/ozone/platform/wayland/host/wayland_window.h
index d68d4d818f28f..2c5afbb3de99c 100644
--- a/ui/ozone/platform/wayland/host/wayland_window.h
+++ b/ui/ozone/platform/wayland/host/wayland_window.h
@@ -230,6 +230,8 @@ class WaylandWindow : public PlatformWindow,
   // currently bound to.
   virtual void HandleSurfaceConfigure(uint32_t serial);
 
+  void OnSurfaceContentChanged();
+
   struct WindowStates {
     bool is_maximized = false;
     bool is_fullscreen = false;
diff --git a/ui/ozone/platform/wayland/host/wayland_window_drag_controller.cc b/ui/ozone/platform/wayland/host/wayland_window_drag_controller.cc
index e38565635a583..ff201c038efb7 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_drag_controller.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_drag_controller.cc
@@ -91,7 +91,7 @@ class WaylandWindowDragController::ExtendedDragSource {
     auto* surface = window ? window->root_surface()->surface() : nullptr;
     zcr_extended_drag_source_v1_drag(source_.get(), surface, offset.x(),
                                      offset.y());
-    connection_->Flush();
+    connection_->ScheduleFlush();
   }
 
  private:
diff --git a/ui/ozone/platform/wayland/host/wayland_window_factory.cc b/ui/ozone/platform/wayland/host/wayland_window_factory.cc
index 6f66c6654819c..e2bc045e4b3fb 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_factory.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_factory.cc
@@ -12,6 +12,8 @@
 #include "ui/ozone/platform/wayland/host/wayland_window.h"
 #include "ui/platform_window/platform_window_init_properties.h"
 
+#include "ui/ozone/platform/wayland/host/wayland_extensions.h"
+
 namespace ui {
 
 // static
@@ -29,6 +31,12 @@ std::unique_ptr<WaylandWindow> WaylandWindow::Create(
       // toplevel window instead.
       if (auto* parent = connection->window_manager()->GetWindow(
               properties.parent_widget)) {
+        if (connection->extensions()) {
+          window = connection->extensions()->CreateWaylandWindow(delegate,
+                                                                 connection);
+          if (window)
+            break;
+        }
         window = std::make_unique<WaylandPopup>(delegate, connection, parent);
       } else {
         DLOG(WARNING) << "Failed to determine parent for menu/popup window.";
@@ -40,6 +48,12 @@ std::unique_ptr<WaylandWindow> WaylandWindow::Create(
     case PlatformWindowType::kDrag:
       // TODO(crbug.com/1399419): Figure out what kind of surface we need to
       // create for kBubble and kDrag windows.
+      if (connection->extensions()) {
+        window =
+            connection->extensions()->CreateWaylandWindow(delegate, connection);
+        if (window)
+          break;
+      }
       window = std::make_unique<WaylandToplevelWindow>(delegate, connection);
       break;
     default:
diff --git a/ui/ozone/platform/wayland/host/wayland_zwp_linux_dmabuf.cc b/ui/ozone/platform/wayland/host/wayland_zwp_linux_dmabuf.cc
index 33935db68eadd..15f600ed7a126 100644
--- a/ui/ozone/platform/wayland/host/wayland_zwp_linux_dmabuf.cc
+++ b/ui/ozone/platform/wayland/host/wayland_zwp_linux_dmabuf.cc
@@ -104,7 +104,7 @@ void WaylandZwpLinuxDmabuf::CreateBuffer(const base::ScopedFD& fd,
     // created buffer and notify the client about it via the |callback|.
     pending_params_.emplace(std::move(params), std::move(callback));
   }
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 bool WaylandZwpLinuxDmabuf::CanCreateBufferImmed() const {
@@ -147,7 +147,7 @@ void WaylandZwpLinuxDmabuf::NotifyRequestCreateBufferDone(
   DCHECK(it != pending_params_.end());
   std::move(it->second).Run(wl::Object<wl_buffer>(new_buffer));
   pending_params_.erase(it);
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 // static
diff --git a/ui/ozone/platform/wayland/host/xdg_foreign_wrapper.cc b/ui/ozone/platform/wayland/host/xdg_foreign_wrapper.cc
index 293c09a7e35f2..d36db127ec057 100644
--- a/ui/ozone/platform/wayland/host/xdg_foreign_wrapper.cc
+++ b/ui/ozone/platform/wayland/host/xdg_foreign_wrapper.cc
@@ -158,7 +158,7 @@ void XdgForeignWrapperImpl<zxdg_exporter_v1, zxdg_exported_v1>::
                                 &kXdgExportedListener, this);
 
   exported_surfaces_.emplace_back(std::move(exported_surface));
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 template <>
@@ -174,7 +174,7 @@ void XdgForeignWrapperImpl<zxdg_exporter_v2, zxdg_exported_v2>::
                                 &kXdgExportedListener, this);
 
   exported_surfaces_.emplace_back(std::move(exported_surface));
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 // static
diff --git a/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc b/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc
index 64c8f2663ae60..b0d8f27aebbf9 100644
--- a/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc
+++ b/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc
@@ -239,7 +239,7 @@ bool XDGPopupWrapperImpl::SetBounds(const gfx::Rect& new_bounds) {
   xdg_popup_reposition(xdg_popup_.get(), positioner.get(),
                        ++next_reposition_token_);
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return true;
 }
 
diff --git a/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc b/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc
index c4dd8c8e78ce4..67702ecc8fa4f 100644
--- a/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc
+++ b/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc
@@ -39,7 +39,7 @@ bool XDGSurfaceWrapperImpl::Initialize() {
   };
   xdg_surface_add_listener(xdg_surface_.get(), &kXdgSurfaceListener, this);
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return true;
 }
 
diff --git a/ui/ozone/platform/wayland/host/xdg_toplevel_wrapper_impl.cc b/ui/ozone/platform/wayland/host/xdg_toplevel_wrapper_impl.cc
index 0673c59185348..b9462c60a2eee 100644
--- a/ui/ozone/platform/wayland/host/xdg_toplevel_wrapper_impl.cc
+++ b/ui/ozone/platform/wayland/host/xdg_toplevel_wrapper_impl.cc
@@ -720,7 +720,7 @@ void XDGToplevelWrapperImpl::ShowSnapPreview(
 
 void XDGToplevelWrapperImpl::AckRotateFocus(uint32_t serial, uint32_t handled) {
   zaura_toplevel_ack_rotate_focus(aura_toplevel_.get(), serial, handled);
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 XDGToplevelWrapperImpl* XDGToplevelWrapperImpl::AsXDGToplevelWrapper() {
diff --git a/ui/ozone/platform/wayland/host/zwp_primary_selection_device.cc b/ui/ozone/platform/wayland/host/zwp_primary_selection_device.cc
index 9057d1bea0116..97c1624e200ac 100644
--- a/ui/ozone/platform/wayland/host/zwp_primary_selection_device.cc
+++ b/ui/ozone/platform/wayland/host/zwp_primary_selection_device.cc
@@ -32,7 +32,7 @@ void ZwpPrimarySelectionDevice::SetSelectionSource(
   auto* data_source = source ? source->data_source() : nullptr;
   zwp_primary_selection_device_v1_set_selection(data_device_.get(), data_source,
                                                 serial);
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 // static
diff --git a/ui/ozone/platform/wayland/host/zwp_primary_selection_device_manager.cc b/ui/ozone/platform/wayland/host/zwp_primary_selection_device_manager.cc
index 9d5d79635b66d..2ca82ce6031ba 100644
--- a/ui/ozone/platform/wayland/host/zwp_primary_selection_device_manager.cc
+++ b/ui/ozone/platform/wayland/host/zwp_primary_selection_device_manager.cc
@@ -66,7 +66,7 @@ ZwpPrimarySelectionDevice* ZwpPrimarySelectionDeviceManager::GetDevice() {
         connection_,
         zwp_primary_selection_device_manager_v1_get_device(
             device_manager_.get(), connection_->seat()->wl_object()));
-    connection_->Flush();
+    connection_->ScheduleFlush();
   }
   DCHECK(device_);
   return device_.get();
@@ -77,7 +77,7 @@ ZwpPrimarySelectionDeviceManager::CreateSource(
     ZwpPrimarySelectionSource::Delegate* delegate) {
   auto* data_source = zwp_primary_selection_device_manager_v1_create_source(
       device_manager_.get());
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return std::make_unique<ZwpPrimarySelectionSource>(data_source, connection_,
                                                      delegate);
 }
diff --git a/ui/platform_window/agl/platform_window_agl.h b/ui/platform_window/agl/platform_window_agl.h
new file mode 100644
index 0000000000000..4bc915d663e72
--- /dev/null
+++ b/ui/platform_window/agl/platform_window_agl.h
@@ -0,0 +1,36 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef UI_PLATFORM_WINDOW_AGL_PLATFORM_WINDOW_AGL_H_
+#define UI_PLATFORM_WINDOW_AGL_PLATFORM_WINDOW_AGL_H_
+
+#include <string>
+
+namespace ui {
+
+// AGL additions for platform window.
+class PlatformWindowAgl {
+ public:
+  virtual void SetAglActivateApp(const std::string& app) {}
+  virtual void SetAglAppId(const std::string& title) {}
+  virtual void SetAglReady() {}
+  virtual void SetAglBackground() {}
+  virtual void SetAglPanel(uint32_t edge) {}
+};
+
+}  // namespace ui
+
+#endif  // UI_PLATFORM_WINDOW_AGL_PLATFORM_WINDOW_AGL_H_
diff --git a/ui/platform_window/platform_window.h b/ui/platform_window/platform_window.h
index 845da9467d6a4..a9b28388ec649 100644
--- a/ui/platform_window/platform_window.h
+++ b/ui/platform_window/platform_window.h
@@ -9,6 +9,7 @@
 #include <string>
 #include <vector>
 
+#include "agl/platform_window_agl.h"
 #include "base/component_export.h"
 #include "ui/base/class_property.h"
 #include "ui/base/ui_base_types.h"
@@ -32,7 +33,8 @@ class PlatformCursor;
 
 // Generic PlatformWindow interface.
 class COMPONENT_EXPORT(PLATFORM_WINDOW) PlatformWindow
-    : public PropertyHandler {
+    : public PropertyHandler,
+      public PlatformWindowAgl {
  public:
   PlatformWindow();
   ~PlatformWindow() override;
-- 
2.42.1

